generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Enums ───────────────────────────────────────────────────────────────────

enum TeamKind {
  PERSONAL
  STANDARD
  ENTERPRISE
}

enum BillingMode {
  SUBSCRIPTION
  WALLET
  HYBRID
  ENTERPRISE_CONTRACT
}

enum TeamMemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum TeamMemberStatus {
  ACTIVE
  REMOVED
}

enum BillingEntityType {
  TEAM
  ORG
}

enum AppSecretStatus {
  ACTIVE
  REVOKED
}

// ─── Models ──────────────────────────────────────────────────────────────────

model App {
  id     String @id @default(uuid())
  name   String
  status String @default("ACTIVE")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users             User[]
  secrets           AppSecret[]
  externalTeamRefs  ExternalTeamRef[]
  plans             Plan[]
  addons            Addon[]
  bundleApps        BundleApp[]
  bundleMeterPolicies BundleMeterPolicy[]
  contractOverrides ContractOverride[]
}

model Team {
  id               String      @id @default(uuid())
  name             String
  kind             TeamKind
  ownerUserId      String?
  defaultCurrency  String      @default("USD")
  stripeCustomerId String?
  billingMode      BillingMode @default(SUBSCRIPTION)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner         User?              @relation("PersonalTeamOwner", fields: [ownerUserId], references: [id])
  members       TeamMember[]
  billingEntity BillingEntity?
  externalRefs  ExternalTeamRef[]
  subscriptions TeamSubscription[]
  teamAddons    TeamAddon[]

  // Unique partial index: one Personal Team per user
  // Prisma doesn't natively support partial unique indexes, so we use raw SQL
  @@index([ownerUserId])
}

model User {
  id          String @id @default(uuid())
  appId       String
  email       String
  externalRef String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  app           App          @relation(fields: [appId], references: [id])
  memberships   TeamMember[]
  personalTeams Team[]       @relation("PersonalTeamOwner")

  @@unique([appId, externalRef])
  @@index([appId, email])
}

model TeamMember {
  id        String           @id @default(uuid())
  teamId    String
  userId    String
  role      TeamMemberRole   @default(MEMBER)
  status    TeamMemberStatus @default(ACTIVE)
  startedAt DateTime         @default(now())
  endedAt   DateTime?

  team Team @relation(fields: [teamId], references: [id])
  user User @relation(fields: [userId], references: [id])

  @@unique([teamId, userId])
  @@index([teamId, status])
}

model BillingEntity {
  id     String            @id @default(uuid())
  type   BillingEntityType @default(TEAM)
  teamId String?           @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  team           Team?          @relation(fields: [teamId], references: [id])
  ledgerAccounts LedgerAccount[]
  ledgerEntries  LedgerEntry[]
  usageEvents    UsageEvent[]
  contracts      Contract[]
}

model ExternalTeamRef {
  id             String @id @default(uuid())
  appId          String
  externalTeamId String
  billingTeamId  String

  createdAt DateTime @default(now())

  app         App  @relation(fields: [appId], references: [id])
  billingTeam Team @relation(fields: [billingTeamId], references: [id])

  @@unique([appId, externalTeamId])
  @@index([billingTeamId])
}

model AppSecret {
  id         String          @id @default(uuid())
  appId      String
  kid        String          @unique
  secretHash String
  status     AppSecretStatus @default(ACTIVE)
  createdAt  DateTime        @default(now())
  revokedAt  DateTime?

  app App @relation(fields: [appId], references: [id])

  @@index([appId, status])
}

model JtiUsage {
  jti       String   @id
  expiresAt DateTime

  @@index([expiresAt])
}

// ─── Bundles & Enterprise Contracts ──────────────────────────────────────────

enum MeterLimitType {
  NONE
  INCLUDED
  UNLIMITED
  HARD_CAP
}

enum MeterEnforcement {
  NONE
  SOFT
  HARD
}

enum OverageBilling {
  NONE
  PER_UNIT
  TIERED
  CUSTOM
}

enum ContractStatus {
  DRAFT
  ACTIVE
  PAUSED
  ENDED
}

enum BillingPeriod {
  MONTHLY
  QUARTERLY
}

enum PricingMode {
  FIXED
  FIXED_PLUS_TRUEUP
  MIN_COMMIT_TRUEUP
  CUSTOM_INVOICE_ONLY
}

enum ContractRateCardKind {
  CUSTOMER
  COGS
}

model Bundle {
  id     String @id @default(uuid())
  code   String @unique
  name   String
  status String @default("ACTIVE")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  apps          BundleApp[]
  meterPolicies BundleMeterPolicy[]
  contracts     Contract[]
}

model BundleApp {
  id                  String @id @default(uuid())
  bundleId            String
  appId               String
  defaultFeatureFlags Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bundle Bundle @relation(fields: [bundleId], references: [id])
  app    App    @relation(fields: [appId], references: [id])

  @@unique([bundleId, appId])
}

model BundleMeterPolicy {
  id             String           @id @default(uuid())
  bundleId       String
  appId          String
  meterKey       String
  limitType      MeterLimitType
  includedAmount Int?
  enforcement    MeterEnforcement @default(NONE)
  overageBilling OverageBilling   @default(NONE)
  notes          String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bundle Bundle @relation(fields: [bundleId], references: [id])
  app    App    @relation(fields: [appId], references: [id])

  @@unique([bundleId, appId, meterKey])
}

model Contract {
  id            String         @id @default(uuid())
  billToId      String
  status        ContractStatus @default(DRAFT)
  bundleId      String
  currency      String
  billingPeriod BillingPeriod
  termsDays     Int
  startsAt      DateTime
  endsAt        DateTime?
  pricingMode   PricingMode

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  billingEntity BillingEntity @relation(fields: [billToId], references: [id])
  bundle        Bundle        @relation(fields: [bundleId], references: [id])
  overrides     ContractOverride[]
  rateCards     ContractRateCard[]

  // Unique partial index: at most one ACTIVE contract per billing entity
  // Prisma doesn't natively support partial unique indexes, so we use raw SQL
  @@index([billToId])
  @@index([bundleId])
}

model ContractOverride {
  id             String            @id @default(uuid())
  contractId     String
  appId          String
  meterKey       String
  limitType      MeterLimitType?
  includedAmount Int?
  overageBilling OverageBilling?
  enforcement    MeterEnforcement?
  featureFlags   Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contract Contract @relation(fields: [contractId], references: [id])
  app      App      @relation(fields: [appId], references: [id])

  @@unique([contractId, appId, meterKey])
}

model ContractRateCard {
  id            String               @id @default(uuid())
  contractId    String
  kind          ContractRateCardKind
  effectiveFrom DateTime
  effectiveTo   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contract Contract @relation(fields: [contractId], references: [id])

  @@index([contractId])
}

// ─── Subscriptions & Products ───────────────────────────────────────────────

enum StripeProductMapKind {
  BASE
  SEAT
  ADDON
  OVERAGE
  TOPUP
}

model Plan {
  id     String @id @default(uuid())
  appId  String
  code   String
  name   String
  status String @default("ACTIVE")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  app               App                @relation(fields: [appId], references: [id])
  stripeProductMaps StripeProductMap[]
  subscriptions     TeamSubscription[]

  @@unique([appId, code])
}

model Addon {
  id     String @id @default(uuid())
  appId  String
  code   String
  name   String
  status String @default("ACTIVE")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  app               App                @relation(fields: [appId], references: [id])
  stripeProductMaps StripeProductMap[]
  teamAddons        TeamAddon[]

  @@unique([appId, code])
}

model StripeProductMap {
  id              String             @id @default(uuid())
  appId           String
  planId          String?
  addonId         String?
  stripeProductId String
  stripePriceId   String
  kind            StripeProductMapKind

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  plan  Plan?  @relation(fields: [planId], references: [id])
  addon Addon? @relation(fields: [addonId], references: [id])

  @@unique([appId, stripePriceId])
}

// ─── Team Subscriptions ────────────────────────────────────────────────────

enum TeamSubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
  TRIALING
  UNPAID
}

model TeamSubscription {
  id                    String                 @id @default(uuid())
  teamId                String
  stripeSubscriptionId  String                 @unique
  status                TeamSubscriptionStatus
  planId                String
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  seatsQuantity         Int                    @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  team Team @relation(fields: [teamId], references: [id])
  plan Plan @relation(fields: [planId], references: [id])

  @@index([teamId])
}

model TeamAddon {
  id       String @id @default(uuid())
  teamId   String
  addonId  String
  status   String @default("ACTIVE")
  quantity Int    @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  team  Team  @relation(fields: [teamId], references: [id])
  addon Addon @relation(fields: [addonId], references: [id])

  @@index([teamId])
  @@index([addonId])
}

// ─── Ledger ────────────────────────────────────────────────────────────────

enum LedgerAccountType {
  WALLET
  ACCOUNTS_RECEIVABLE
  REVENUE
  COGS
  TAX
}

enum LedgerEntryType {
  TOPUP
  SUBSCRIPTION_CHARGE
  USAGE_CHARGE
  REFUND
  ADJUSTMENT
  INVOICE_PAYMENT
  COGS_ACCRUAL
}

enum LedgerReferenceType {
  STRIPE_INVOICE
  STRIPE_PAYMENT_INTENT
  USAGE_EVENT
  MANUAL
}

model LedgerAccount {
  id       String            @id @default(uuid())
  appId    String
  billToId String
  type     LedgerAccountType

  createdAt DateTime @default(now())

  billingEntity BillingEntity @relation(fields: [billToId], references: [id])
  entries       LedgerEntry[]

  @@unique([appId, billToId, type])
}

model LedgerEntry {
  id              String              @id @default(uuid())
  appId           String
  billToId        String
  ledgerAccountId String
  timestamp       DateTime            @default(now())
  type            LedgerEntryType
  amountMinor     Int
  currency        String
  referenceType   LedgerReferenceType
  referenceId     String?
  idempotencyKey  String              @unique
  metadata        Json?

  createdAt DateTime @default(now())

  billingEntity BillingEntity @relation(fields: [billToId], references: [id])
  ledgerAccount LedgerAccount @relation(fields: [ledgerAccountId], references: [id])

  @@index([billToId, timestamp])
  @@index([ledgerAccountId, timestamp])
}

// ─── Usage Events (Immutable) ─────────────────────────────────────────────

model UsageEvent {
  id             String   @id @default(uuid())
  appId          String
  teamId         String
  billToId       String
  userId         String?
  eventType      String
  timestamp      DateTime
  idempotencyKey String
  payload        Json
  source         String

  createdAt DateTime @default(now())

  billingEntity BillingEntity @relation(fields: [billToId], references: [id])

  @@unique([appId, idempotencyKey])
  @@index([appId, teamId, timestamp])
  @@index([billToId, timestamp])
}

// ─── Stripe Webhooks ────────────────────────────────────────────────────────

model StripeWebhookEvent {
  id          String   @id @default(uuid())
  eventId     String   @unique
  eventType   String
  processedAt DateTime @default(now())

  @@index([processedAt])
}
