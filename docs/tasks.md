# Tasks — UnlikeOtherSubscriptions

## Section 1: Project Foundation

[ ] Initialize project scaffolding
Source: docs/architecture.md, CLAUDE.md
Set up the Node.js + TypeScript project from scratch. Create `package.json` with Fastify, Prisma, Zod, Pino, pg-boss, and Stripe dependencies. Configure `tsconfig.json` with strict mode. Create the folder structure: `src/routes/`, `src/controllers/`, `src/services/`, `src/repositories/`, `src/workers/`, `src/middleware/`, `src/lib/`, `src/types/`, `prisma/`. Create `.env.example` with all required environment variables (DATABASE_URL, STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, JWT_SECRET, PORT). Create `.gitignore` (node_modules, dist, .env, prisma/*.db). Add `dev`, `build`, `start`, `test`, `lint` scripts. Tests: verify `npm install` succeeds, `tsc --noEmit` passes, folder structure exists, `.env.example` contains all required keys.

[ ] Define Prisma schema for core identity models
Source: docs/architecture.md (Multi-Tenant Foundations section)
Create `prisma/schema.prisma` with the core models: `App` (id, name, status), `Team` (id, name, kind enum PERSONAL/STANDARD/ENTERPRISE, ownerUserId nullable, defaultCurrency, stripeCustomerId nullable, billingMode enum SUBSCRIPTION/WALLET/HYBRID/ENTERPRISE_CONTRACT), `User` (id, appId, email, externalRef), `TeamMember` (teamId, userId, role enum OWNER/ADMIN/MEMBER, status enum ACTIVE/REMOVED, startedAt, endedAt nullable), `BillingEntity` (id, type enum TEAM/ORG, teamId unique nullable), `ExternalTeamRef` (appId, externalTeamId, billingTeamId with unique constraint on appId+externalTeamId), and `AppSecret` (id, appId, kid unique, secretHash, status enum ACTIVE/REVOKED, createdAt, revokedAt nullable). Add the unique partial index on Team for `(ownerUserId) WHERE kind = 'PERSONAL'`. Add all foreign key relationships. Run `npx prisma migrate dev` to verify the schema is valid. Tests: migration applies cleanly, all models can be created via Prisma Client, unique constraints reject duplicates (e.g. duplicate ownerUserId for PERSONAL teams, duplicate appId+externalTeamId).

[ ] Implement health check endpoint and Fastify server bootstrap
Source: docs/architecture.md (HTTP API, Observability sections)
Create the Fastify server entry point with Pino structured JSON logging. Register a `GET /healthz` endpoint that returns `{ status: "ok" }` and checks database connectivity via Prisma. Add a request correlation ID middleware that generates a UUID `x-request-id` header on every request (or propagates an incoming one) and attaches it to the Pino logger child context. Configure Fastify with proper error handling (Zod validation errors return 400 with structured error response, unknown errors return 500 with correlation ID). Set up graceful shutdown (close Prisma, drain pg-boss). Tests: health check returns 200 when DB is up, correlation IDs are present in responses and logs, validation errors return structured 400 responses, server shuts down gracefully.

## Section 2: Authentication & App Registration

[ ] Implement JWT auth middleware
Source: docs/architecture.md (Service-to-Service Authentication section)
Build Fastify middleware (preHandler hook) that extracts the `Authorization: Bearer <jwt>` header, decodes the JWT header to read `kid`, looks up the corresponding `AppSecret` by `kid` (must be ACTIVE status), verifies the HMAC signature using the secret, validates standard claims (`iss` matches `app:{appId}`, `aud` is `billing-service`, `exp` is not past, `iat` is not in the future), and attaches the decoded claims (appId, teamId, userId, scopes) to the Fastify request object. Implement replay protection: store `jti` values with their `exp` timestamp in a Postgres table (or cache), reject any JWT whose `jti` has been seen before. The middleware must skip JWT auth for the Stripe webhook route. Tests: valid JWT passes and claims are attached to request, expired JWT returns 401, invalid signature returns 401, missing/malformed header returns 401, replayed jti returns 401, revoked kid returns 401, Stripe webhook route bypasses JWT check.

[ ] Implement App registration and secret management
Source: docs/architecture.md (App model, Auth secrets)
Create admin endpoints for App lifecycle: `POST /v1/admin/apps` (create an App with name, returns appId), `POST /v1/admin/apps/:appId/secrets` (generate a new HMAC secret, store hashed in `AppSecret` with a unique `kid`, return the plaintext secret and kid to the caller exactly once), `DELETE /v1/admin/apps/:appId/secrets/:kid` (revoke a secret by setting status to REVOKED and revokedAt). Support multiple active secrets per App to enable zero-downtime key rotation. Tests: create App returns valid appId, generate secret returns kid + plaintext secret, the secret can be used to sign a valid JWT that passes auth middleware, revoking a secret causes JWTs signed with it to fail auth, an App can have multiple active secrets simultaneously, generating a secret for a nonexistent App returns 404.

## Section 3: Identity & Provisioning

[ ] Implement User provisioning endpoint
Source: docs/architecture.md (Identity & Provisioning API, Workflow A)
Implement `POST /v1/apps/:appId/users` which accepts `{ email, externalRef }` and is idempotent (upsert on appId+externalRef). On first creation, auto-create a Personal Team: create Team with `kind=PERSONAL`, `ownerUserId` set, `billingMode=SUBSCRIPTION`; create a BillingEntity with `type=TEAM`; create a TeamMember with `role=OWNER`, `status=ACTIVE`. Return the User record and the Personal Team ID. If the User already exists, return the existing records without modification. Validate that `appId` in the JWT matches the route param. Tests: first call creates User + Personal Team + BillingEntity + TeamMember, second call with same externalRef is idempotent and returns same IDs, unique constraint prevents two Personal Teams for same user, returned Personal Team has correct kind/owner/billingMode, JWT appId mismatch returns 403.

[ ] Implement Team CRUD endpoints
Source: docs/architecture.md (Identity & Provisioning API, Workflow A2)
Implement `POST /v1/apps/:appId/teams` which accepts `{ name, externalTeamId? }` and creates a Team with `kind=STANDARD`. Auto-create a BillingEntity with `type=TEAM`. If `externalTeamId` is provided, create an ExternalTeamRef mapping. The endpoint must be idempotent: if an ExternalTeamRef already exists for this appId+externalTeamId, return the existing Team. Implement `GET /v1/apps/:appId/teams/:teamId` to retrieve Team details including billingMode and stripeCustomerId. Tests: create Team returns teamId with kind=STANDARD, BillingEntity is auto-created, ExternalTeamRef is created when externalTeamId provided, duplicate externalTeamId for same App returns existing Team (idempotent), retrieving a Team returns correct fields, creating a Team for nonexistent App returns 404.

[ ] Implement TeamMember management and seat tracking
Source: docs/architecture.md (TeamMember model, Workflow D)
Implement `POST /v1/apps/:appId/teams/:teamId/users` which accepts `{ userId, role? }` and ensures the user is a member of the team. If the user is not a member, create a TeamMember with `status=ACTIVE` and `startedAt=now`. If already a member, return existing membership (idempotent). Track active seat count: implement a `getActiveSeatCount(teamId)` service method that counts TeamMembers with `status=ACTIVE`. Implement `DELETE /v1/apps/:appId/teams/:teamId/users/:userId` which sets `status=REMOVED` and `endedAt=now` (soft delete, never hard delete, for seat history). Tests: adding a user creates TeamMember, adding same user again is idempotent, removing a user sets status to REMOVED with endedAt, active seat count reflects additions and removals, cannot add a user to a nonexistent team (404), seat history is preserved after removal.

## Section 4: Stripe Integration Core

[ ] Implement Stripe customer creation and object mapping
Source: docs/architecture.md (Stripe Integration section)
Implement a `StripeService` that lazily creates a Stripe Customer the first time a Team needs one (on first checkout or subscription). The service should: check if `Team.stripeCustomerId` is already set; if not, call `stripe.customers.create()` with the team name and metadata (teamId, appId), then update the Team record with the returned Stripe customer ID. This must be idempotent (handle race conditions with a unique constraint or compare-and-swap). Implement `getOrCreateStripeCustomer(teamId)` as the primary interface. Tests: first call creates a Stripe customer and stores the ID on the Team, second call returns the same customer ID without calling Stripe again, concurrent calls do not create duplicate customers, the Stripe customer metadata contains teamId.

[ ] Implement subscription checkout flow
Source: docs/architecture.md (Workflow B, Ledger & Billing API)
Implement `POST /v1/apps/:appId/teams/:teamId/checkout/subscription` which accepts `{ planCode, successUrl, cancelUrl, seats? }`. Look up the Plan and its StripeProductMap entries, call `getOrCreateStripeCustomer(teamId)`, then create a Stripe Checkout Session in `subscription` mode with the appropriate line items (base price + seat price if applicable). Return `{ url, sessionId }`. Validate that the Plan belongs to the requesting App. Tests: returns a valid Checkout Session URL, uses the correct Stripe price IDs from StripeProductMap, creates a Stripe customer if one does not exist, rejects planCode not belonging to the App (404), rejects requests for teams that do not exist (404), seat quantity is passed correctly to Stripe line items.

[ ] Implement Stripe webhook handler with signature verification and event deduplication
Source: docs/architecture.md (Stripe Webhook Handler section, Stripe Webhook API)
Implement `POST /v1/stripe/webhook` with raw body parsing (required for Stripe signature verification). Verify the webhook signature using `stripe.webhooks.constructEvent()` with the webhook signing secret. Implement event deduplication: store each processed `event.id` in a `StripeWebhookEvent` table (id, eventType, processedAt); reject duplicates. Route verified events to domain-specific handler functions based on event type. Return 200 immediately after verification and dedup check (process asynchronously if needed). Tests: valid signature is accepted and event is stored, invalid signature returns 400, duplicate event.id is rejected with 200 (idempotent), unsupported event types are acknowledged but ignored, raw body parsing works correctly (not JSON-parsed before signature check).

[ ] Implement webhook handlers for subscription lifecycle events
Source: docs/architecture.md (Handled webhook events, Workflow B steps 4-6)
Implement handlers for: `checkout.session.completed` (create or update TeamSubscription with status, planId, period dates, seatsQuantity; write a ledger entry for the subscription charge), `customer.subscription.updated` (update TeamSubscription status and period dates), `customer.subscription.deleted` (mark TeamSubscription as cancelled), `invoice.paid` (write a ledger entry of type SUBSCRIPTION_CHARGE), `invoice.payment_failed` (write a ledger entry of type ADJUSTMENT, optionally flag the team for grace period). Each handler must be idempotent (use Stripe event ID as idempotency reference). After any subscription state change, trigger entitlement recomputation (can be a simple function call in V1). Tests: checkout.session.completed creates TeamSubscription and ledger entry, subscription.updated updates period dates, subscription.deleted marks as cancelled, invoice.paid creates correct ledger entry, payment_failed creates adjustment entry, duplicate event processing is idempotent, entitlements are refreshed after subscription changes.

## Section 5: Subscriptions & Entitlements

[ ] Define Prisma schema for Plans, Addons, and Subscriptions
Source: docs/architecture.md (Subscriptions & Products section)
Add to the Prisma schema: `Plan` (id, appId, code unique per app, name, status), `Addon` (id, appId, code unique per app, name, status), `StripeProductMap` (id, appId, planId nullable, addonId nullable, stripeProductId, stripePriceId, kind enum BASE/SEAT/ADDON/OVERAGE/TOPUP), `TeamSubscription` (id, teamId, stripeSubscriptionId unique, status, planId, currentPeriodStart, currentPeriodEnd, seatsQuantity), `TeamAddon` (id, teamId, addonId, status, quantity). Add foreign keys and indexes. Tests: migration applies cleanly, can create Plans and Addons, StripeProductMap correctly links to Plan or Addon, TeamSubscription enforces unique stripeSubscriptionId, all relationships query correctly via Prisma includes.

[ ] Implement basic entitlement resolution
Source: docs/architecture.md (Entitlement Resolution Algorithm section)
Implement `resolveEntitlements(appId, teamId)` following the documented algorithm. For V1 without enterprise contracts: look up the Team's BillingEntity, check for an ACTIVE contract (if none, use plan-based resolution), look up the Team's active TeamSubscription for the given App, resolve the Plan's entitlements (features and meter policies). Return an `EntitlementResult` object containing: features (boolean flags), meter policies (limitType, includedAmount, enforcement, overageBilling per meter), billingMode (from Team), and billable flags. Implement `GET /v1/apps/:appId/teams/:teamId/entitlements` endpoint that calls this resolver. Tests: team with active subscription returns correct plan entitlements, team with no subscription returns default/free entitlements, team with cancelled subscription returns default entitlements, the billingMode field reflects the Team's current mode, nonexistent team returns 404.

[ ] Implement Stripe customer portal session creation
Source: docs/architecture.md (Ledger & Billing API)
Implement `POST /v1/apps/:appId/teams/:teamId/portal` which accepts `{ returnUrl }`. Look up the Team's stripeCustomerId (return 400 if no Stripe customer exists yet). Create a Stripe Billing Portal session via `stripe.billingPortal.sessions.create()` with the customer ID and return URL. Return `{ url }`. Tests: returns a valid portal session URL for a team with a Stripe customer, returns 400 for a team without a Stripe customer, validates that the team belongs to the requesting App.

## Section 6: Usage Ingestion

[ ] Implement usage event ingestion endpoint
Source: docs/architecture.md (Usage Ingestion API, UsageEvent model), docs/brief.md (Canonical Event Contract)
Implement `POST /v1/apps/:appId/usage/events` which accepts a batch array of usage events. Each event must contain: idempotencyKey, eventType (versioned string), timestamp, payload, source. teamId is conditionally required (if not provided, userId must be present and the server resolves teamId from the user's Personal Team). Validate the batch with Zod: max batch size (e.g. 1000 events), each event validated individually. For each event: resolve billToId from the Team's BillingEntity, insert into UsageEvent table. Idempotency: use unique constraint on (appId, idempotencyKey) and ON CONFLICT DO NOTHING. Return `{ accepted: number, duplicates: number }`. Tests: single event is stored correctly, batch of events is stored, duplicate idempotencyKey is silently ignored and counted, missing teamId with valid userId resolves to Personal Team, missing both teamId and userId returns 400, invalid eventType format returns 400, billToId is correctly resolved and stored, batch exceeding max size returns 400, source field is stored.

[ ] Implement usage event schema registry and validation
Source: docs/architecture.md (Event Schema Versioning section), docs/brief.md (Event Schema Versioning)
Create a schema registry that maps eventType strings to JSON Schema definitions. Register the V1 schemas: `llm.tokens.v1` (requires provider, model, inputTokens, outputTokens; optional cachedTokens), `llm.image.v1` (requires provider, model, width, height, count), `storage.sample.v1` (requires bytesUsed), `bandwidth.sample.v1` (requires bytesIn, bytesOut; optional bytesOutInternal). During usage event ingestion, validate each event's payload against the registered schema for its eventType. Reject events with unknown eventTypes or invalid payloads with specific error messages. The registry should be extensible (new schemas can be added without code changes in the future, but V1 schemas are hardcoded). Tests: valid llm.tokens.v1 payload passes validation, missing required fields are rejected with field-level errors, unknown eventType is rejected, extra fields in payload are allowed (tolerant reader), each V1 schema validates its specific structure correctly.

## Section 7: Pricing Engine

[ ] Define Prisma schema for PriceBook, PriceRule, and BillableLineItem
Source: docs/architecture.md (Pricing section, Billable Line Items section)
Add to the Prisma schema: `PriceBook` (id, appId, kind enum COGS/CUSTOMER, currency, version int, effectiveFrom, effectiveTo nullable), `PriceRule` (id, priceBookId, priority int, match JSONB, rule JSONB), `BillableLineItem` (id, appId, billToId references BillingEntity, teamId, userId nullable, usageEventId nullable, timestamp, priceBookId, priceRuleId, amountMinor int, currency, description, inputsSnapshot JSONB). Add indexes on BillableLineItem: (appId, teamId, timestamp), (billToId, timestamp). Add foreign keys. Tests: migration applies cleanly, can create PriceBooks with COGS and CUSTOMER kinds, PriceRules are linked to PriceBooks, BillableLineItems reference both billToId and teamId, inputsSnapshot stores and retrieves JSONB correctly.

[ ] Implement pricing engine core
Source: docs/architecture.md (Pricing section, PriceRule model, Billing Correctness Rule)
Implement a `PricingEngine` service with a `priceEvent(usageEvent)` method. The engine: finds the effective PriceBook(s) for the event's appId at the event timestamp (both COGS and CUSTOMER books), matches PriceRules by evaluating the `match` JSONB against the event's payload (provider, model, eventType), selects the highest-priority matching rule, evaluates the `rule` JSONB to compute amountMinor. Support rule types: `flat` (fixed amount), `per_unit` (unit price * quantity from payload), `tiered` (graduated tiers with different rates). Each BillableLineItem must store priceBookId, priceRuleId, amountMinor, currency, and inputsSnapshot. The engine must produce two BillableLineItems per event: one for COGS and one for CUSTOMER pricing. Tests: flat rule produces correct amount, per_unit rule multiplies correctly (e.g. inputTokens * rate), tiered rule applies correct tier rates, highest-priority rule wins when multiple match, COGS and CUSTOMER line items are both created, inputsSnapshot captures the computation inputs, no matching rule returns an error or skips gracefully.

[ ] Implement pricing engine worker
Source: docs/architecture.md (Background Workers section)
Implement a pg-boss worker that processes unpriced UsageEvents. The worker: polls for UsageEvents that do not yet have corresponding BillableLineItems (use a `pricedAt` nullable timestamp on UsageEvent, or a join check), calls `PricingEngine.priceEvent()` for each, writes the resulting BillableLineItems in a transaction. The worker must be idempotent (re-processing an already-priced event produces no duplicate line items). Configure the worker with a batch size and polling interval. Handle errors gracefully: failed events should be retried with backoff, permanently failed events should be logged and flagged. Tests: unpriced events are picked up and priced, already-priced events are skipped, worker processes events in batches, failed pricing (e.g. no matching rule) does not block other events, worker is idempotent on re-runs, BillableLineItems are created in a transaction (all-or-nothing per event).

## Section 8: Ledger & Wallet

[ ] Define Prisma schema for LedgerAccount and LedgerEntry
Source: docs/architecture.md (Ledger section)
Add to the Prisma schema: `LedgerAccount` (id, appId, billToId references BillingEntity, type enum WALLET/ACCOUNTS_RECEIVABLE/REVENUE/COGS/TAX, unique constraint on appId+billToId+type), `LedgerEntry` (id, appId, billToId references BillingEntity, ledgerAccountId, timestamp, type enum TOPUP/SUBSCRIPTION_CHARGE/USAGE_CHARGE/REFUND/ADJUSTMENT/INVOICE_PAYMENT/COGS_ACCRUAL, amountMinor int, currency, referenceType enum STRIPE_INVOICE/STRIPE_PAYMENT_INTENT/USAGE_EVENT/MANUAL, referenceId nullable, idempotencyKey unique, metadata JSONB nullable). Add indexes on LedgerEntry: (billToId, timestamp), (ledgerAccountId, timestamp). Tests: migration applies cleanly, LedgerAccount unique constraint prevents duplicates, LedgerEntry idempotencyKey prevents duplicate financial actions, entries can be queried by billToId and time range, JSONB metadata stores and retrieves correctly.

[ ] Implement ledger service
Source: docs/architecture.md (Ledger section, Security & Hard Edges)
Implement a `LedgerService` with methods: `createEntry(params)` (creates a LedgerEntry with idempotency key check, in a transaction), `getBalance(appId, billToId, accountType)` (sums amountMinor for all entries on the specified LedgerAccount), `getEntries(appId, billToId, { from, to, type? })` (queries entries with optional filters). Auto-create LedgerAccounts on first use (get-or-create pattern). All balance-affecting operations must use database transactions with appropriate isolation (SERIALIZABLE or advisory locks per billToId). Implement `GET /v1/apps/:appId/teams/:teamId/ledger` endpoint that returns paginated ledger entries. Tests: create entry with idempotency key succeeds first time, duplicate idempotency key is rejected, balance computation is correct after credits and debits, concurrent balance operations do not produce incorrect results, ledger endpoint returns filtered entries by date range, entries are append-only (no update/delete operations exposed).

[ ] Implement wallet top-up checkout and auto-top-up trigger
Source: docs/architecture.md (Ledger & Billing API, Workflow C)
Implement `POST /v1/apps/:appId/teams/:teamId/checkout/topup` which accepts `{ amountMinor, currency, successUrl, cancelUrl }`. Create a Stripe Checkout Session in `payment` mode (one-time) for the specified amount. On `payment_intent.succeeded` webhook, create a TOPUP ledger entry crediting the team's WALLET account. Implement auto-top-up logic: a configurable threshold (stored on Team or BillingEntity) and top-up amount; when wallet balance drops below threshold during usage debit processing, automatically create a Stripe PaymentIntent for the top-up amount. Tests: top-up checkout creates a valid Stripe session, webhook handler creates TOPUP ledger entry with correct amount, wallet balance increases after top-up, auto-top-up triggers when balance drops below threshold, auto-top-up does not trigger when balance is sufficient, duplicate payment_intent webhooks are handled idempotently.

[ ] Implement wallet debit flow
Source: docs/architecture.md (Workflow C step 5 — Wallet mode)
Implement the wallet debit path for usage charges. When a BillableLineItem is created for a team in WALLET billingMode: create a USAGE_CHARGE ledger entry debiting the WALLET account (negative amountMinor). Support two modes: immediate (debit on each BillableLineItem creation) and daily batch (aggregate BillableLineItems for a period and create a single debit entry). After each debit, check the wallet balance and trigger auto-top-up if below threshold. Implement a pg-boss scheduled job for daily batch mode that aggregates unprocessed billable line items and creates batch debit entries. Tests: immediate debit creates ledger entry per BillableLineItem, daily batch aggregates correctly, wallet balance decreases after debits, auto-top-up is triggered when balance drops below threshold, batch job is idempotent (does not double-debit), debit entries reference the correct BillableLineItem(s).

## Section 9: Enterprise Contracts

[ ] Define Prisma schema for Bundles and Contracts
Source: docs/architecture.md (Bundles & Enterprise Contracts section)
Add to the Prisma schema: `Bundle` (id, code unique, name, status), `BundleApp` (id, bundleId, appId, defaultFeatureFlags JSONB nullable, unique on bundleId+appId), `BundleMeterPolicy` (id, bundleId, appId, meterKey, limitType enum NONE/INCLUDED/UNLIMITED/HARD_CAP, includedAmount int nullable, enforcement enum NONE/SOFT/HARD, overageBilling enum NONE/PER_UNIT/TIERED/CUSTOM, notes nullable, unique on bundleId+appId+meterKey), `Contract` (id, billToId references BillingEntity, status enum DRAFT/ACTIVE/PAUSED/ENDED, bundleId, currency, billingPeriod enum MONTHLY/QUARTERLY, termsDays int, startsAt, endsAt nullable, pricingMode enum FIXED/FIXED_PLUS_TRUEUP/MIN_COMMIT_TRUEUP/CUSTOM_INVOICE_ONLY), `ContractOverride` (id, contractId, appId, meterKey, limitType, includedAmount, overageBilling, enforcement, featureFlags JSONB nullable, unique on contractId+appId+meterKey), `ContractRateCard` (id, contractId, kind enum CUSTOMER/COGS, effectiveFrom, effectiveTo nullable). Add unique partial index on Contract: `(billToId) WHERE status = 'ACTIVE'`. Tests: migration applies cleanly, unique partial index prevents two ACTIVE contracts for same billToId, BundleMeterPolicy unique constraint works, ContractOverride unique constraint works, all foreign keys enforce referential integrity.

[ ] Implement enterprise entitlement resolution
Source: docs/architecture.md (Entitlement Resolution Algorithm section)
Extend the `resolveEntitlements` function to handle the enterprise path. When a Team's BillingEntity has an ACTIVE Contract: load the Contract's Bundle and its BundleApps, load BundleMeterPolicies for the requested appId, load ContractOverrides for the requested appId, merge using the priority cascade (ContractOverride > BundleMeterPolicy > Plan > Defaults). Set billingMode to ENTERPRISE_CONTRACT. For each meter, the highest-priority source that defines a policy wins. Return the merged EntitlementResult. Tests: team with active contract returns enterprise entitlements, ContractOverride takes priority over BundleMeterPolicy, BundleMeterPolicy takes priority over plan defaults, UNLIMITED limitType is correctly represented, team with ACTIVE contract has billingMode=ENTERPRISE_CONTRACT, team whose contract is PAUSED falls back to plan-based resolution, app not in the bundle returns default entitlements.

[ ] Implement contract admin endpoints
Source: docs/architecture.md (Enterprise Contracts & Bundles API)
Implement: `POST /v1/contracts` (create a contract in DRAFT status with billToId, bundleId, currency, billingPeriod, termsDays, pricingMode, startsAt, endsAt), `PATCH /v1/contracts/:id` (update status, terms, or pricingMode; transitioning to ACTIVE triggers the unique partial index check), `PUT /v1/contracts/:id/overrides` (replace all overrides for a contract with the provided array of per-app/meter overrides), `POST /v1/bundles` (create a bundle with code, name, apps, and meter policies), `PATCH /v1/bundles/:id` (update bundle apps or meter policies). All mutations must trigger entitlement recomputation for affected teams. Tests: create contract in DRAFT status succeeds, activate contract succeeds when no other ACTIVE contract exists, activating a second contract for same billToId fails (unique constraint), updating overrides replaces all existing overrides, creating a bundle with apps and policies works, entitlements change after contract activation, entitlements revert after contract is set to ENDED.

## Section 10: Invoicing & Period Close

[ ] Define Prisma schema for Invoice and InvoiceLineItem
Source: docs/architecture.md (Invoicing section)
Add to the Prisma schema: `Invoice` (id, billToId references BillingEntity, contractId nullable, periodStart, periodEnd, status enum DRAFT/ISSUED/PAID/VOID, subtotalMinor int, taxMinor int, totalMinor int, externalRef nullable, issuedAt nullable, dueAt nullable), `InvoiceLineItem` (id, invoiceId, appId nullable, type enum BASE_FEE/USAGE_TRUEUP/ADDON/CREDIT/ADJUSTMENT, description, quantity int, unitPriceMinor int, amountMinor int, usageSummary JSONB nullable). Add indexes on Invoice: (billToId, periodStart, periodEnd), (contractId). Tests: migration applies cleanly, Invoice status enum works, InvoiceLineItem types are correctly stored, usageSummary JSONB stores and retrieves correctly, invoices can be queried by billToId and period.

[ ] Implement period close worker
Source: docs/architecture.md (Workflow F — Enterprise Contract Billing)
Implement a pg-boss scheduled worker that runs at the end of each billing period for active contracts. The worker: finds all ACTIVE contracts whose current period has ended, aggregates BillableLineItems per app and meter for the period, generates an Invoice based on pricingMode (FIXED: single BASE_FEE line; FIXED_PLUS_TRUEUP: BASE_FEE + USAGE_TRUEUP lines for overages; MIN_COMMIT_TRUEUP: max of usage total vs minimum commit; CUSTOM_INVOICE_ONLY: draft invoice for manual review). Write ledger entries for all invoice line items. Mark the invoice as ISSUED (or DRAFT for CUSTOM_INVOICE_ONLY). The worker must be idempotent (do not generate duplicate invoices for the same period). Tests: FIXED mode generates single BASE_FEE invoice, FIXED_PLUS_TRUEUP generates correct overage lines, MIN_COMMIT_TRUEUP charges the greater of usage vs minimum, CUSTOM_INVOICE_ONLY creates draft invoice, ledger entries are created for each line item, re-running the worker for the same period does not create duplicate invoices, worker handles multiple contracts in a single run.

[ ] Implement invoice management endpoints
Source: docs/architecture.md (Invoice Management API)
Implement: `POST /v1/invoices/generate` (manually trigger invoice generation for a specific team and period, useful for ad-hoc or non-contract invoices), `GET /v1/invoices/:id` (retrieve invoice details including all line items), `POST /v1/invoices/:id/export` (return invoice data as structured JSON suitable for external systems; PDF generation is out of scope for V1), `POST /v1/invoices/:id/mark-paid` (admin action that transitions status from ISSUED to PAID, creates an INVOICE_PAYMENT ledger entry, requires audit logging). Tests: generate creates an invoice with correct line items and totals, retrieve returns full invoice with line items, export returns structured JSON, mark-paid transitions status and creates ledger entry, mark-paid on non-ISSUED invoice returns 400, duplicate mark-paid is idempotent, all admin actions are audit-logged.

## Section 11: Usage Reporting & Schema Discovery

[ ] Implement usage reporting endpoints
Source: docs/architecture.md (Usage Reporting API)
Implement: `GET /v1/teams/:teamId/usage` with query params `from`, `to`, and `groupBy` (one of: app, meter, provider, model). Aggregate BillableLineItems for the team within the date range, grouped by the specified dimension. Return totals (amountMinor for both COGS and CUSTOMER) and counts per group. Implement `GET /v1/teams/:teamId/cogs` with `from` and `to` params that returns COGS-only BillableLineItems aggregated by app and meter. Both endpoints must validate that the requesting App has appropriate scopes. Tests: usage grouped by app returns correct totals, usage grouped by meter returns correct totals, usage grouped by provider returns correct totals, COGS report returns only COGS line items, date range filtering works correctly, empty date range returns empty results, scope validation rejects unauthorized access.

[ ] Implement schema discovery and capabilities endpoints
Source: docs/architecture.md (Schema Discovery Endpoints, Capabilities Endpoint)
Implement: `GET /v1/schemas/usage-events` (list all registered event type schemas with their versions and status), `GET /v1/schemas/usage-events/:eventType` (return the JSON Schema definition for a specific event type, e.g. `llm.tokens.v1`), `GET /v1/meta/capabilities` (return the service's current capabilities: supported event types and versions, available meters, max batch size for usage ingestion, rate limits if any). These endpoints help client tools discover what the billing service supports without reading documentation. Tests: list schemas returns all registered V1 event types, get specific schema returns valid JSON Schema, unknown eventType returns 404, capabilities endpoint returns correct max batch size, capabilities include all supported event types, response format is stable and documented.

## Section 12: SDK

[ ] Implement TypeScript billing SDK
Source: docs/brief.md (Shared Client SDK), README.md (Integration section)
Create the `@unlikeotherai/billing-sdk` package (in a `packages/sdk/` directory or separate publishable package). The SDK provides a `createBillingClient({ appId, secret, baseUrl })` factory that returns a client with methods: `reportUsage(events[])` (batches and posts usage events to `/v1/apps/:appId/usage/events`, signs requests with JWT using the configured secret, handles idempotency), `getEntitlements(teamId)` (calls `GET /v1/apps/:appId/teams/:teamId/entitlements`, returns typed EntitlementResult), `createCheckout(teamId, options)` (calls `POST /v1/apps/:appId/teams/:teamId/checkout/subscription`, returns `{ url }`). The SDK must: generate JWTs with correct claims (iss, aud, sub, appId, teamId, scopes, exp, jti, kid), handle HTTP errors with typed error classes, support configurable timeout and retry with exponential backoff. Tests: reportUsage sends correctly formatted request with valid JWT, getEntitlements returns typed result, createCheckout returns URL, JWT contains all required claims, expired secret is handled gracefully, network errors trigger retry, batch size validation is enforced client-side, SDK can round-trip against the real API endpoints in integration tests.

## Open Design Decisions

> The following items are noted as decisions that will be finalized during implementation. They do not block task execution but should be documented when resolved.

- **Ledger single-entry vs double-entry:** V1 uses single-entry (one LedgerEntry per financial action). Double-entry can be adopted later if audit requirements demand it.
- **Pricing rule schemas:** The exact JSON structure for `flat`, `per_unit`, `tiered`, and `formula` rule types will be defined during pricing engine implementation (Task: "Implement pricing engine core").
- **Feature flags data model:** How plan-level and bundle-level feature flags are stored and resolved will be defined during entitlement implementation.
- **Worker scheduling and retry configuration:** pg-boss job options (cron expressions, retry counts, backoff strategy) will be configured during worker implementation.
- **Request/response schemas:** Full OpenAPI request/response schemas will be generated from Zod validators during implementation and stored in `openapi/v1.yaml`.
